---
title: "Introduction to geocodebr"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
code-annotations: hover
urlcolor: blue
vignette: >
  %\VignetteIndexEntry{Introduction to geocodebr}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = identical(tolower(Sys.getenv("NOT_CRAN")), "true"),
  out.width = "100%"
)

```


Reprex
```{r, eval = FALSE}
library(geocodebr)

# open input data
data_path <- system.file("extdata/small_sample.csv", package = "geocodebr")
input_df <- read.csv(data_path)

# indicate the columns describing the address fields
fields <- setup_address_fields(
  logradouro = "nm_logradouro",
  numero = "Numero",
  cep = "Cep",
  bairro = "Bairro",
  municipio = "nm_municipio",
  estado = "nm_uf"
  )

# geocode 
df <- geocode(
  addresses_table = input_df,
  address_fields = fields,
  n_cores = 1,
  progress = TRUE
  )

head(df)
```



#' Think for example of a building with several apartments that match the same
#' street address. In such case, the coordinates of the apartments will differ
#' very slightly, and {geocodebr} take the average of those coordinates. On the
#' other hand, in the loosest case, in which only the state and the city are
#' matched, geocodebr takes the city-wide average coordinates, which tends to
#' favor more densely populated areas. The columns considered in each of the 12
#' different match types are described below:

#' In a less rigorous example, in which only the fields (estado, municipio, bairro) are
#' matched, {geocodebr} calculates average coordinates of all addresses in CNEFE
#' 
#' 
#' , which tends to
#' favor more densely populated areas. The columns considered in each of the 12
#' different match types are described below:

